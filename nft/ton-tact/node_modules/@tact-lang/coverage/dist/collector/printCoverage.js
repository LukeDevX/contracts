"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printCoverage = void 0;
const opcode_1 = require("@tact-lang/opcode");
const text_1 = require("../utils/text");
function span(src, className) {
    return `<span class="${className}">${src}</span>`;
}
function template(src) {
    return (0, text_1.trimIndent)(`
    <html>
        <head>
            <style>
                pre {
                    display: flex;
                    flex-direction: column;
                }
                .padding {
                    color: #ccc;
                }
                .line-covered {
                    background-color: #DDFFDD;
                }
                .line-uncovered {
                    background-color: #fffcdd;
                }
                .count {
                    display: inline-flex;
                    width: 30px;
                    justify-content: center;
                    color: #10620d;
                }
                .gas {
                    display: inline-flex;
                    width: 30px;
                    justify-content: center;
                    color: #e60f0f;
                }
            </style>
        </head>
        <body>
            <h1>Code coverage</h1>
            <pre>
            ${(0, text_1.pad)((0, text_1.trimIndent)(src), 16)}
            </pre>
        <body>
    </html>
    `);
}
function printCoverage(code, collector) {
    // Create printer
    const printer = (src, indent) => {
        if (typeof src === 'string') {
            return span(span(``, 'count') + span(``, 'gas') + span('.'.repeat(indent * 2), 'padding') + src, 'line');
        }
        let line = span('.'.repeat(indent * 2), 'padding') + span(src.op, 'opcode');
        // console.log(src.hash.toLowerCase());
        // console.log(src);
        let cov = collector.coverageForCell(src.hash.toLowerCase());
        let lineClass;
        if (cov && cov.offsets.has(src.offset)) {
            let d = cov.offsets.get(src.offset);
            line = span(`x${d.count}`, 'count') + line;
            if (src.length > 0) { // Ignore non-opcode lines
                // let min = d.gas.reduce((a, b) => a < b ? a : b, d.gas[0]);
                let max = d.gas.reduce((a, b) => a > b ? a : b, d.gas[0]);
                // if (min !== max) {
                //     line = span(`${min} - ${max}`, 'gas') + line;
                // } else {
                //     line = span(`${min}`, 'gas') + line;
                // }
                line = span(`${max}`, 'gas') + line;
            }
            else {
                line = span(``, 'gas') + line;
            }
            lineClass = 'line-covered';
        }
        else {
            line = span(``, 'count') + line;
            line = span(``, 'gas') + line;
            lineClass = 'line-uncovered';
        }
        return span(line, lineClass);
    };
    // Decompile with coverage
    let decompiled = (0, opcode_1.decompileAll)({ src: code, printer });
    // Process template and return result
    return template(decompiled);
}
exports.printCoverage = printCoverage;
